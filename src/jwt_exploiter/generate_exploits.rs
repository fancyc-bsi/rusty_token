use crate::error::JWTAnalyzerError;
use crate::types::{ExploitResult, Severity};
use std::sync::Arc;
use futures::future;
use tokio::task;
use super::JWTExploiter;

impl JWTExploiter {
    pub async fn generate_exploits(self: Arc<Self>) -> Result<Vec<ExploitResult>, JWTAnalyzerError> {
        let mut tasks = Vec::new();
    
        for vuln in &self.discovered_vulnerabilities {
            match vuln.severity {
                Severity::Critical => {
                    if vuln.description.contains("Algorithm 'none'") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_none_algorithm().await
                        }));
                    }
                    if vuln.description.contains("Signature stripping") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_stripped_signature().await
                        }));
                    }
                }
                Severity::High => {
                    if vuln.description.contains("Weak HMAC key") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_with_weak_key().await
                        }));
                    }
                    if vuln.description.contains("key confusion") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_key_confusion().await
                        }));
                    }
                    if vuln.description.contains("KID injection") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_kid_injection().await
                        }));
                    }
                    if vuln.description.contains("JWK embedded") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_jwk_injection().await
                        }));
                    }
                }
                _ => {}
            }
        }
    
        // Await all tasks and gather results, propagating any errors
        let results = future::try_join_all(tasks).await?;
    
        // Collect the exploit results after unwrapping
        let exploits = results.into_iter().collect::<Result<Vec<_>, _>>()?;
    
        Ok(exploits)
    }
}