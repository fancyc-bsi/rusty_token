use crate::error::JWTAnalyzerError;
use crate::types::{ExploitResult, Severity};
use std::collections::HashSet;
use std::sync::Arc;
use futures::future;
use tokio::task;
use super::JWTExploiter;


impl JWTExploiter {
    pub async fn generate_exploits(self: Arc<Self>) -> Result<Vec<ExploitResult>, JWTAnalyzerError> {
        let mut tasks = Vec::new();
    
        for vuln in &self.discovered_vulnerabilities {
            match vuln.severity {
                Severity::Critical => {
                    if vuln.description.contains("Algorithm 'none'") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_none_algorithm().await
                        }));
                    }
                    if vuln.description.contains("Signature stripping") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_stripped_signature().await
                        }));
                    }
                }
                Severity::High => {
                    if vuln.description.contains("Weak HMAC key") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_with_weak_key().await
                        }));
                    }
                    if vuln.description.contains("key confusion") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_key_confusion().await
                        }));
                    }
                    if vuln.description.contains("KID injection") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_kid_injection().await
                        }));
                    }
                    if vuln.description.contains("JWK embedded") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_jwk_injection().await
                        }));
                    }
                }
                Severity::Medium => {
                    if vuln.description.contains("Expired token") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_expired_token().await
                        }));
                    }
                    if vuln.description.contains("password validation") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_blank_password().await
                        }));
                    }
                }
                Severity::Low => {
                    if vuln.description.contains("Missing") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_missing_claims().await
                        }));
                    }
                    if vuln.description.contains("Algorithm case sensitivity") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_algorithm_case().await
                        }));
                    }
                    if vuln.description.contains("payload size") {
                        let self_clone = Arc::clone(&self);
                        tasks.push(task::spawn(async move {
                            self_clone.forge_large_payload().await
                        }));
                    }
                }

            }
        }
    
        // Await all tasks and gather results, propagating any errors
        let results = future::try_join_all(tasks).await?;
    
        // Collect the exploit results after unwrapping
        let unique_exploits: HashSet<_> = results.into_iter().collect::<Result<HashSet<_>, _>>()?;
        
        // Convert HashSet back to Vec for returning
        Ok(unique_exploits.into_iter().collect())
    }
}